R = [(13, 1, 2), (18, 1, 3), (17, 1, 4), (14, 1, 5), (22, 1, 6),
     (26, 2, 3), (22, 2, 5), (3, 3, 4), (19, 4, 6)]
#рёбра в дереве (длина, вершина 1, вершина 2)
Rsort = sorted(R, key=lambda x: x[0]) #сортировка рёбер по возрастанию, k определяет параметр сортировки
U = set() #list of connected tops
D = {} #словарь изолированных вершин. Определяет, какая вершина к какой группе относится
T = [] #список рёбер минимального остова

for i in Rsort:
    if r[1] not in U or r[2] not in U: #проверка на изолированность вершин
        if r[1] not in U and r[2] not in U: #если обе вершины не соединены, то
            D[r[1]] = [r[1], r[2]] #формируем словарь, который будет содержать список соединённой группы вершин
            D[r[2]] = D[r[1]] #и связываем эти вершины с одним и тем же списком  вершин
        else:
            if not D.get(r[1]): #если в словаре нет первой вершины, то
                D[r[2]].append(r[1]) #добавляем в список первую вершину
                D[r[1]] = D[r[2]] #снова связываем вершины с одним и тем же списком вершин
            else:
                D[r[1]].append(r[2]) #то же самое со второй вершиной
                D[r[2]] = D[r[1]]

        T.append{r) #добавляем в список остова ребро с минимальым весом
        U.add(r[1]) #добавляем вершины в множество U
        U.add(r[2])

for r in Rsort: #проходим по рёбрам второй раз и объединяем разделённые группы вершин
    if r[2] not in D[r[1]]: #если вершины в разных группах вершин, то объединяем
        T.append(r) #добавляем ребро с минимальным весом в остов
        gr1 = D[r[1]]
        D[r[1]] += D[r[2]] #объединяем списки двух групп вершин
        D[r[2]] += gr1

print(T)
